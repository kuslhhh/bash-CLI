const e=e=>Array.isArray(e)?e:[e],l=t=>{var n,a,o;const v=null!==(n=null==t?void 0:t.mapKey)&&void 0!==n?n:e=>e,s=new Map(null!==(a=null==t?void 0:t.values)&&void 0!==a?a:[]),i=new Map(null!==(o=null==t?void 0:t.keys)&&void 0!==o?o:[]),r={$$cache:s,has:e=>!!r.get(e),clear:()=>{s.clear(),i.clear()},clone:()=>l({...t,values:s,keys:i}),set:(l,t)=>{var n;const a=null!=t?t:l;let o=s;const r=e(v(l));for(let e=0,t=r.length;e<t;e++){const v=r[e];e!==t-1?((null===(n=o.get(v))||void 0===n?void 0:n.next)||o.set(v,{next:new Map}),o=o.get(v).next):o.has(v)?(o.get(v).value=a,o.get(v).params=l):(i.set(l,r),o.set(v,{value:a,params:l}))}},get:l=>{var t,n;let a,o=s;const i=e(v(l));for(let e=0,l=i.length;e<l;e++){const v=i[e];if(e===l-1){a=null===(t=o.get(v))||void 0===t?void 0:t.value;break}if(o=null===(n=o.get(v))||void 0===n?void 0:n.next,!o)break}return a},delete:l=>{var t,n,a;let o=s;const r=[],d=e(v(l));for(let e=0,l=d.length;e<l;e++){const v=d[e];if(e!==l-1){if(!o.value){const e=o;r.unshift((()=>{var l;(null===(l=e.get(v))||void 0===l?void 0:l.next)||e.delete(v)}))}if(o=null===(a=o.get(v))||void 0===a?void 0:a.next,!o)break}else void 0!==(null===(t=o.get(v))||void 0===t?void 0:t.value)&&(i.delete(o.get(v).params),delete o.get(v).value,delete o.get(v).params),(null===(n=o.get(v))||void 0===n?void 0:n.next)||(o.delete(v),r.forEach((e=>e())))}},keys:()=>[...i.keys()]};return r};export{l as createCache};
